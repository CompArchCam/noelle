==== SOFTWARE ENGINEERING
- Add the option to decide the number of threads to target per loop

- Reconsider all abstractions (e.g., do we need all LoopSummary, LoopInfoSummary, and LoopDependenceInfo? do we need SCCEdgeInfo?)

- Create a "Dependence" abstraction, which is DG<Value>
  - have methods like "getSource(), getDestination(), isMemoryBased()"

==== AUTOTUNER
- Extend the autotuner to decide #threads per loop

- Extend the autotuner to decide the parallelization-specific parameters (e.g., chunk size for DOALL, SCCDAG partitioning for DSWP)


==== Parallelizer
- Modify parallelizer to be able to parallelize multiple loops nested to each other at the same time


==== DOALL
- BUGFIX: Swap outer and inner loops (See Builder.cpp:78)
- Promote chunk size to be an option (e.g., --doall-chunksize)


==== OTHER PARALLELIZATION SCHEMES
- Implement PS-DSWP

- Implement HELIX


==== OPTIMIZATIONS
- Inline calls involved in an SCC and rerun the PDG analysis

- Packing/unpacking pushes and pops

- Create a new pass to map memory locations to variables as much as possible
  This removes the overly conservative memory loop-carried data dependences


Task log - Angelo
  - min-max partition heuristic
  - clean up analysis classes (SCCDAGAttrs, SimpleIVInfo, ...)
  Write a test pass to scan AA of a simple global variable program
  LiveIn APIs for loading all live in variables (HELIX, DOALL), and loading a subset (DSWP)
  CloneLoop APIs for whole loop at once (DOALL), and sets and sets of BBs (DSWP)
  Confirm data flow between clones is generalizable
  PropagateLiveOuts -> GenerateCodeToLoadLiveOutVars
  PopulateEnvironment -> GenerateCodeTOCreateEnvironment
  live in, live out naming

==== Worker construction

DOALL structure:
  Create entry, exit
  Clone whole loop
  Load env
  Remap data/control flow
  Introduce outer/inner loop chunk structure
  Store env

DSWP structure:
  Create entry, exit
  Clone subset of loop
  Add queue push/pop
  Add env load/store
  Remap data/control flow
  Inline queue calls

Proposed structure:
  - Inlinined steps in DOALL/DSWP apply
  - Shift from StageInfo/ChunkerInfo to TechniqueWorker
  Prepare
    Helper that identifies mapping between entry and exit(s) DONE
    Helper that initializes an env user DONE
  Base clone
    DOALL: Clone whole DONE
    DSWP: Determine subset to clone DONE
  Augment clone
    DOALL: Introduce outer/inner loop NOT
      - Look at Builder.cpp
      - Handle new mapping on preheader and exit
    DSWP: Trim CFG, introduce queues NOT
  Handle environment (ALMOST DONE)
    Load live ins, store live outs DOING
      - Steps are in DOALL/DSWP Environment.cpp
  Data flow
    Reroute clones, environment, etc... DOING
  Optimize structure
    DSWP: Inline queue calls

DOALL: outer loop
  Start value: IV start + core ind * chunk size
  Step size: num cores * chunk size * [IV step (should always be 1?) ]
  Cmp: cmpToExclusive (unsigned lt), brancing to exit if not true

DOALL: inner loop
  Start value: 0
  Step size: accumulator step (should always be 1?)
  Composite IV: outer + inner
    Replace all uses
  Cmp:
    1) outer + inner < cmpToExclusive
      Ensure sum instruction is before the cmp
    2) inner < chunk size

Outer loop contains original header PHIs
Inner loop is generated, and either
  1) ensures no other PHIs exist in the original header
  2) generates adjusted PHIs in the inner loop
    Is this necessary? Would these other PHIs break the condition for DOALL?
    Conditions for DOALL:
      one exit block
      all live outs are reducable
      the loop has an IV
      all loop carried dependencies are:
        commutative, contained in a subloop, or clonable
        (reducable, self contained, side effect free)
    So it is possible:
      For some i_ = c, i++ / i--, if you have another IV such as
      j_ = d, j+=s, then convert to j'', j'_ = 0, j'++/j'--, j'' = d + j'
      and then set j'' = d + (j'_ - i_) + i

Instructions don't seem to be cloned into the correct function...
Referring to another BB (check all BB mappings are added before data flow mapping)
Stored value type does not match pointer operand type (they seem the same)
